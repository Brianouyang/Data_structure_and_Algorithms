# 27. 什么是递归

## Recursion递归

- 递归是一种解决问题的方法，其精髓在于

    将问题分解为规模更小的相同问题

    持续分解，直到问题规模小到可以用非常简单直接地方式来解决

    在算法流程种调用自身

## 初识递归：数列求和

- 给定一个列表，返回所有数的和
- 程序很简单，但是不用循环语句呢？

    既不能用for也不能用while

    还能对不确定长度的列表求和么？

- 我们认识到求和实际上最终是由一次次的加法实现的，而加法恰好有两个操作数
- 换个方式来表达数列求和：全括号表示

    （1+（3+（5+（7+9）））

    观察上述问题，可以把求和问题归纳为：

    数列的和=“首个数”+“余下数列”的和

    如果数列包含的数少到只有1的时候，它的和就是这个数

    ![27%20%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%92%E5%BD%92%20e7145c66a87f4b3daf887531fef754ab.png](27%20%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%92%E5%BD%92%20e7145c66a87f4b3daf887531fef754ab.png)

    ```python
    def listsum(numList):
        if len(numList) == 1:
            return numList[0]
        else:
            return numList[0] + listsum(numList[1:])

    print(listsum([1,3,5,7,9]))
    ```

    要点：

    1. 问题分解为更小规模的相同问题，并表现为“调用自身”
    2. 对“最小规模”问题的解决：简单直接

## 递归三定律

1. 递归算法必须有一个基本结束条件
2. 递归算法必须能改变状态向基本结束条件演进
3. 递归算法必须调用自身

## 递归三定律：数列求和问题

- 基本结束条件：当列表长度为1的时候，直接输出所包含的唯一数
- 数列求和处理的数据对象是一个列表，而基本结束条件是长度为1的列表，那递归算法就要改变列表并向长度为1的状态的演进
- 调用自身是递归算法中最难理解的部分，实际上我们理解为“问题分解了规模更小的相同问题“就可以了

---