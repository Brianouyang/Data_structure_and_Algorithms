# 59. 优先队列和二叉堆

## 优先队列Priority Queue

队列有一种变体称为“优先队列”

银行系统操作vip用户，提前某个人的进程

优先队列的出队跟队列一样从队首出队

但在优先队列内部，数据项的次序却是由“优先级”来确定的：

高优先级的数据项排在队首，而低优先级的数据项排在队尾

这样，数据项的入队操作就会比较复杂，需要将数据项根据其优先级尽量挤到队列前方

## 二叉堆Binary Heap实现优先队列

实现优先队列的经典方案是采用二叉堆数据结构

二叉堆能够优先队列的入队和出队复杂度都保持在 $O(\log n)$

二叉堆有趣之处是逻辑结构是二叉树，但是是用非嵌套的列表实现的

最小key排在队首的称为最小堆min heap，反之

[ADT BinaryHeap](59%20%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8C%E5%8F%89%E5%A0%86%205449e915c72a4063a485854e5a2cf40f/ADT%20BinaryHeap%20a4c7173e5b0a4164b39448e4e3a7970d.csv)

## 用非嵌套列表实现二叉堆

为了使堆能够保持在对数上，就必须采用二叉树结构

同样，如果要使操作始终保持在对数数量级上，就必须始终保持二叉树的平衡

树根左右子树拥有相同数量的节点

我们采用完全二叉树的结构来近似实现平衡

完全二叉树，叶节点最多只出现在最底层和次底层，而且最底层的叶节点都连续集中在最左边，每个内部节点都有两个子节点，最多可以有一个节点例外

![59%20%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8C%E5%8F%89%E5%A0%86%205449e915c72a4063a485854e5a2cf40f/compTree.png](59%20%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8C%E5%8F%89%E5%A0%86%205449e915c72a4063a485854e5a2cf40f/compTree.png)

A Complete Binary Tree

## 完全二叉树的列表实现及性质

完全二叉树由于其特殊性，可以用非嵌套列表，以简单的方式实现，具有很好性质

如果节点的下标为p，那么其左子节点下标为2p，右子节点为2p+1，其父节点下标为p//2

![59%20%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8C%E5%8F%89%E5%A0%86%205449e915c72a4063a485854e5a2cf40f/heapOrder.png](59%20%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8C%E5%8F%89%E5%A0%86%205449e915c72a4063a485854e5a2cf40f/heapOrder.png)

## 堆次序Heap Order

任何一个节点x，其父节点p中的key均小于x中的key

这样，符合“堆”性质的二叉树，其中任何一条路径，均是一个已排数列，根节点的key最小

![59%20%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8C%E5%8F%89%E5%A0%86%205449e915c72a4063a485854e5a2cf40f/heapOrder%201.png](59%20%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8C%E5%8F%89%E5%A0%86%205449e915c72a4063a485854e5a2cf40f/heapOrder%201.png)